/*
 * ArgonMS MapleStory server emulator written in Java
 * Copyright (C) 2011-2013  GoldenKevin
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package argonms.center.net.remoteadmin;

import argonms.common.net.OrderedQueue;
import argonms.common.net.Session;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

//TODO: find some kind of application-level keepalive, or just kick users after
//a idle timeout.
/**
 *
 * @author GoldenKevin
 */
public class TelnetSession implements Session {
	private static final Logger LOG = Logger.getLogger(TelnetSession.class.getName());
	private static final int BUFFER_SIZE = 1024;

	private static final Charset ascii = Charset.forName("US-ASCII");
	private static final String newLine = "\r\n";
	private static final Pattern newLineRegex = Pattern.compile(newLine);
	private static final int newLineLength = newLine.length();

	private final SocketChannel commChn;
	private final AtomicBoolean closeEventsTriggered;
	private final ByteBuffer readBuffer;
	private final TelnetClient client;

	private final SelectionKey selectionKey;
	private final OrderedQueue sendQueue;

	private final CommandReceivedDelegate commandHandler;
	private final Lock readLock;
	private final StringBuilder inputBuffer;
	private int inputCount;
	private int inputCursor;

	/* package-private */ interface CommandReceivedDelegate {
		public void lineReceived(String message, TelnetClient client);
	}

	/* package-private */ TelnetSession(SocketChannel channel, SelectionKey key, TelnetClient client, CommandReceivedDelegate processor) {
		closeEventsTriggered = new AtomicBoolean(false);
		readBuffer = ByteBuffer.allocate(BUFFER_SIZE);
		sendQueue = new OrderedQueue();
		readLock = new ReentrantLock();
		inputBuffer = new StringBuilder(BUFFER_SIZE);

		this.commChn = channel;
		this.client = client;
		this.selectionKey = key;
		this.commandHandler = processor;
	}

	public TelnetClient getClient() {
		return client;
	}

	@Override
	public SocketAddress getAddress() {
		return commChn.socket().getRemoteSocketAddress();
	}

	private void send(ByteBuffer buf) {
		int queueInsertNo = sendQueue.getNextPush();
		sendQueue.insert(queueInsertNo, buf);
		try {
			if (selectionKey.isValid() && !sendQueue.willBlock() && tryFlushSendQueue() == 0) {
				selectionKey.interestOps(selectionKey.interestOps() | SelectionKey.OP_WRITE);
				selectionKey.selector().wakeup();
			}
		} catch (CancelledKeyException e) {
			//don't worry about it - session is already closed
		}
	}

	private void processLine(String line) {
		switch (client.getState()) {
			case LOGIN:
				client.setUsername(line);
				break;
			case PASSWORD:
				send(newLine);
				client.authenticate(line);
				break;
			case MESSAGE:
				commandHandler.lineReceived(line, client);
				if (commChn.isOpen())
					client.writePrompt();
				break;
		}
	}

	public final void send(String message) {
		send(ascii.encode(CharBuffer.wrap(message)));
	}

	@Override
	public void send(byte[] b) {
		send(ByteBuffer.wrap(b));
	}

	@Override
	public boolean close(String reason) {
		if (closeEventsTriggered.compareAndSet(false, true)) {
			try {
				commChn.close();
			} catch (IOException e) {
				LOG.log(Level.FINE, "Error while closing telnet client " + getClient().getAccountName() + " (" + getAddress() + ")", e);
			}

			LOG.log(Level.FINE, "Telnet client {0} ({1}) disconnected: {2}", new Object[] { getClient().getAccountName(), getAddress(), reason });
			client.disconnected();
			return true;
		}
		return false;
	}

	/**
	 * @return 0 if not all queued messages could be sent in a non-blocking
	 * manner, 1 if all queued messages have been successfully sent, -1 if there
	 * is another flush attempt in progress, or -2 if there's an error and the
	 * channel is closed.
	 */
	/* package-private */ byte tryFlushSendQueue() {
		if (!sendQueue.shouldWrite())
			return -1;
		try {
			do {
				int success = 0;
				try {
					Iterator<ByteBuffer> iter = sendQueue.pop().iterator();
					while (iter.hasNext()) {
						ByteBuffer buf = iter.next();
						if (buf.remaining() == commChn.write(buf)) {
							success++;
						} else {
							int i = sendQueue.currentPopBlock() + success;
							sendQueue.insert(i++, buf);
							while (iter.hasNext())
								sendQueue.insert(i++, iter.next());
							return 0;
						}
					}
				} finally {
					sendQueue.incrementPopCursor(success);
				}
			} while (!sendQueue.willBlock());
			return 1;
		} catch (IOException ex) {
			//does an IOException in write always mean an invalid channel?
			close(ex.getMessage());
			return -2;
		} finally {
			sendQueue.setCanWrite();
		}
	}

	private int asciiControlCodesAndVt100(byte[] message, int i, ByteArrayOutputStream echo) {
		switch (message[i]) {
			case '\r':
			case '\n': //new line
				echo.write(message[i]);
				inputBuffer.insert(inputCursor, (char) message[i]);
				inputCursor++;
				inputCount++;
				break;
			case 0x1B: //Esc - swallow the ones we don't care about
				if (i + 1 < message.length) {
					switch (message[i + 1]) {
						case 0x1B:
							//function keys
							if (i + 3 < message.length && i + 1 == 0x31 && i + 3 == '~')
								i += 3;
							break;
						case '[':
							//vt100 escape sequences
							if (i + 2 < message.length) {
								switch (message[i + 2]) {
									case 'A':
										//cursor up
										//TODO: set cursor just to the right of
										//name>, then echo { 0x1B, '[', 'K' },
										//then echo the last line from history,
										//and finally set cursor just to right
										//of brought up text
										i += 2;
										break;
									case 'B':
										//cursor down
										i += 2;
										break;
									case 'C':
										//cursor right
										if (inputCursor < inputCount) {
											echo.write(message, i, 3);
											inputCursor++;
										}
										i += 2;
										break;
									case 'D':
										//cursor left
										//TODO: this should insert chars and
										//shift existing chars to right instead
										//of replacing existing chars when
										//typing after shifting cursor. wrong
										//VT100 codes perhaps? Windows Telnet
										//server and client have it right, so I
										//guess I'll packet sniff them.
										if (inputCursor > 0) {
											echo.write(message, i, 3);
											inputCursor--;
										}
										i += 2;
										break;
								}
							}
							break;
					}
				}
				break;
			case '\b': //ASCII non-destructive backspace (Windows telnet)
				if (inputCursor <= 0)
					break;
				echo.write(message[i]);
				echo.write(' ');
			case 0x7F: //Ctrl-? destructive backspace (PuTTY)
				if (inputCursor > 0) {
					inputCursor--;
					inputCount--;
					inputBuffer.deleteCharAt(inputCursor);
					echo.write(message[i]);
				}
				break;
		}
		return i;
	}

	/**
	 * This may only be called from the TelnetListener boss thread, in the
	 * Selector loop.
	 */
	/* package-private */ void processRead(byte[] message) {
		ByteArrayOutputStream echo = new ByteArrayOutputStream(message.length);
		readLock.lock();
		try { //only one thread altering inputBuffer please.
			for (int i = 0; i < message.length; i++) {
				if (message[i] > 0x1F && message[i] < 0x7F) {
					//7-bit ASCII printable characters
					echo.write(message[i]);
					//since it's 7-bit ASCII, we just cast the byte to char without
					//having to worry about wide chars.
					inputBuffer.insert(inputCursor, (char) message[i]);
					inputCursor++;
					inputCount++;
				} else if (message[i] == TelnetClient.IAC) {
					//Telnet commands
					i += client.protocolCmd(message, i + 1);
				} else {
					//7-bit ASCII control characters
					i = asciiControlCodesAndVt100(message, i, echo);
				}
			}

			if (client.willEcho())
				send(ByteBuffer.wrap(echo.toByteArray()));
			String[] statements = newLineRegex.split(inputBuffer, -1);
			String statement;
			int cutTo = 0;
			for (int i = 0; i < statements.length - 1; i++) {
				statement = statements[i];
				processLine(statement);
				cutTo += statement.length() + newLineLength;
			}
			inputCursor -= cutTo;
			inputCount -= cutTo;
			inputBuffer.delete(0, cutTo);
		} finally {
			readLock.unlock();
		}
	}

	/**
	 * This may only be called from the TelnetListener boss thread, in the
	 * Selector loop.
	 */
	/* package-private */ ByteBuffer readBuffer() {
		return readBuffer;
	}

	/**
	 * This may only be called from the TelnetListener boss thread, in the
	 * Selector loop.
	 * @param readBytes
	 */
	/* package-private */ byte[] readMessage(int readBytes) {
		if (readBytes == -1) {
			//connection closed
			close("EOF received");
			return null;
		}
		readBuffer.flip();
		byte[] message = new byte[readBuffer.remaining()];
		readBuffer.get(message);
		readBuffer.clear();
		return message;
	}
}
